"""ETF Router Definitions"""

from typing import Dict, List, Optional

import pandas as pd
from openbb_core.app.model.obbject import OBBject
from openbb_core.app.utils import basemodel_to_df
from pydantic import ConfigDict, Field


class EtfBase(OBBject):
    __pydantic_config__ = ConfigDict(extra="allow", from_attributes=True) # type: ignore

    model: Optional[str] = Field(description="The OpenBB data model.", default=None)
    provider: Optional[str] = Field(description="The data source.", default=None)
    fields: Optional[List[str]] = Field(
        description="Fields returned from the provider.", default=None
    )
    results: Optional[List] = Field(description="Serialized results.", default=None)
    extra: Optional[Dict] = Field(
        description="Additional information and metadata.", default=None
    )
    warnings: Optional[List] = Field(
        description="Warnings generated by the command execution.", default=None
    )
    id: Optional[str] = Field(
        description="Unique hash string for the request.", default=None
    )


class Results:
    """Class to dynamically parse results from the provider output and get the fields."""

    def __init__(self, data, model):
        items = list(data.__dict__.keys())
        setattr(self, "model", model)
        for item in items:
            setattr(self, item, data.__dict__[item])
        if len(data.results) == 0:
            setattr(self, "fields", [])
        if model == "EtfHoldings" and len(data.results) == 2:
            setattr(self, "info", data.results[1])
            setattr(self, "results", data.results[0])
        if len(self.results) > 0:  # type: ignore
            setattr(
                self,
                "fields",
                sorted(basemodel_to_df(self.results).columns.tolist()),  # type: ignore
            )


class EtfSearch(EtfBase):
    """
    ETFSearchData
    ---------------

        Attributes
        ----------
        model: str
            The OpenBB data model.
        provider: str
            The data source.
        fields: List
            Fields returned from the provider.
        results: List
            Serialized results.
        extra: Dict
            Additional information and metadata.
        warnings: List
            Warnings generated by the command execution.
        id: str
            Unique hash string for the request.

        Methods
        -------
        to_dataframe(): pd.DataFrame
            Convert the results to a Pandas DataFrame.
        to_dict(): Dict
            Convert the results to a dictionary.
    """

    def __repr__(self):
        query = self.dict()["extra"]["metadata"]["arguments"]["standard_params"]["query"]  # type: ignore
        repr_str = (
            f"EtfSearch(provider={self.provider.lower()}, query={query}, "  # type: ignore
            f"fields={self.fields})"
        )
        return repr_str

    def to_dataframe(self) -> pd.DataFrame:
        """Convert the results to a Pandas DataFrame."""
        if len(self.results) == 0:
            return pd.DataFrame()
        data = pd.DataFrame.from_records(self.dict()["results"])
        return data.convert_dtypes()

    def to_dict(self) -> Dict:
        """Convert the results to a dictionary."""
        return self.dict()["results"]


class EtfHoldings(EtfBase):
    """
    ETFHoldingsData
    ---------------

        Attributes
        ----------
        model: str
            The OpenBB data model.
        provider: str
            The data source.
        fields: List
            Fields returned from the provider.
        info: Dict
            Additional information about the daily holdings.  Valid only for providers: ['blackrock', 'fmp']
        results: List
            Serialized results.
        extra: Dict
            Additional information and metadata.
        warnings: List
            Warnings generated by the command execution.
        id: str
            Unique hash string for the request.

        Methods
        -------
        to_dataframe(): pd.DataFrame
            Convert the results to a Pandas DataFrame.
        to_dict(): Dict
            Convert the results to a dictionary.
    """

    info: Optional[Dict] = Field(
        description="Additional information about the daily holdings.  Valid only for providers: ['blackrock', 'fmp']",
        default=None,
    )

    def __repr__(self):
        symbol = self.dict()["extra"]["metadata"]["arguments"]["standard_params"]["symbol"]  # type: ignore
        repr_str = (
            f"EtfHoldings(provider={self.provider.lower()}, symbol={symbol.lower()}, "  # type: ignore
            f"fields={self.fields})"
        )
        return repr_str

    def to_dataframe(self) -> pd.DataFrame:
        """Convert the results to a Pandas DataFrame."""
        if len(self.results) == 0:
            return pd.DataFrame()
        data = pd.DataFrame.from_records(self.dict()["results"]).convert_dtypes()
        for column in data.columns:
            if data[column].unique().tolist()[0] is None:
                data.drop(columns=column, inplace=True)
        return data

    def to_dict(self) -> Dict:
        """Convert the results to a dictionary."""
        return self.dict()["results"]


class EtfSectors(EtfBase):
    """
    ETFSectorsData
    ---------------

        Attributes
        ----------
        model: str
            The OpenBB data model.
        provider: str
            The data source.
        fields: List
            Fields returned from the provider.
        results: List
            Serialized results.
        extra: Dict
            Additional information and metadata.
        warnings: List
            Warnings generated by the command execution.
        id: str
            Unique hash string for the request.

        Methods
        -------
        to_dataframe(): pd.DataFrame
            Convert the results to a Pandas DataFrame.
        to_dict(): Dict
            Convert the results to a dictionary.
    """

    def __repr__(self) -> str:
        symbols = self.dict()["extra"]["metadata"]["arguments"]["standard_params"]["symbol"]  # type: ignore
        repr_str = (
            f"EtfSectors(provider={self.provider.lower()}, symbols=[{symbols}], "  # type: ignore
            f"fields={self.to_dataframe().transpose().reset_index().columns.to_list()})"
        )
        return repr_str

    def to_dataframe(self) -> pd.DataFrame:
        """Convert the results to a Pandas DataFrame."""
        data = pd.DataFrame()
        if len(self.results) > 0:
            data = pd.DataFrame(self.dict()["results"]).set_index("symbol")

        data = data.transpose()
        if len(data.columns) == 1:
            data = data.dropna().sort_values(by=data.columns[0], ascending=False)
        for i in data.index:
            if data.loc[i].unique().tolist()[0] is None:
                data.drop(i, inplace=True)
        return data

    def to_dict(self) -> Dict:
        """Convert the results to a dictionary."""
        return self.dict()["results"]


class EtfCountries(EtfBase):
    """
    ETFSectorsData
    ---------------

        Attributes
        ----------
        model: str
            The OpenBB data model.
        provider: str
            : DataFrameThe data source.
        fields: List
            Fields returned from the provider.
        results: List
            Serialized results.
        extra: Dict
            Additional information and metadata.
        warnings: List
            Warnings generated by the command execution.
        id: str
            Unique hash string for the request.

        Methods
        -------
        to_dataframe(): pd.DataFrame
            Convert the results to a Pandas DataFrame.
        to_dict(): Dict
            Convert the results to a dictionary.
    """

    def __repr__(self) -> str:
        symbols = self.dict()["extra"]["metadata"]["arguments"]["standard_params"]["symbol"]  # type: ignore
        repr_str = (
            f"EtfCountries(provider={self.provider.lower()}, symbols=[{symbols}], "  # type: ignore
            f"fields={self.to_dataframe().transpose().reset_index().columns.to_list()})"
        )
        return repr_str

    def to_dataframe(self) -> pd.DataFrame:
        """Convert the results to a Pandas DataFrame."""
        data = pd.DataFrame()
        if len(self.results) > 0:
            data = pd.DataFrame(self.dict()["results"]).set_index("symbol")

        data = data.transpose()
        if len(data.columns) == 1:
            data = data.dropna().sort_values(by=data.columns[0], ascending=False)
        for i in data.index:
            if data.loc[i].unique().tolist()[0] is None:
                data.drop(i, inplace=True)
        return data

    def to_dict(self) -> Dict:
        """Convert the results to a dictionary."""
        return self.dict()["results"]


class EtfInfo(EtfBase):
    """
    ETFInfoData
    ------------

        Attributes
        ----------
        model: str
            The OpenBB data model.
        provider: str
            The data source.
        fields: List
            Fields returned from the provider.
        results: List
            Serialized results.
        extra: Dict
            Additional information and metadata.
        warnings: List
            Warnings generated by the command execution.
        id: str
            Unique hash string for the request.

        Methods
        -------
        to_dataframe(): pd.DataFrame
            Convert the results to a Pandas DataFrame.
        to_dict(): Dict
            Convert the results to a dictionary.
    """

    def __repr__(self) -> str:
        symbols = self.dict()["extra"]["metadata"]["arguments"]["standard_params"]["symbol"]  # type: ignore
        repr_str = (
            f"EtfInfo(provider={self.provider.lower()}, symbols=[{symbols}], "  # type: ignore
            f"fields={self.to_dataframe().index.to_list()})"
        )
        return repr_str

    def to_dataframe(self) -> pd.DataFrame:
        """Convert the results to a Pandas DataFrame."""
        data = pd.DataFrame()
        if len(self.results) > 0:
            data = pd.DataFrame(self.dict()["results"]).transpose()
            data.columns = data.loc["symbol"].to_list()
            data = data.drop("symbol", axis=0)

        return data

    def to_dict(self) -> Dict:
        """Convert the results to a dictionary."""
        return self.dict()["results"]
